<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;
	charset=utf-8" /> <meta name="Author" content="Sergio
	Barrachina Mir and Germán Fabregat Llueca" />
	<meta name="Description" content="QtARMSim: a graphical
	interface for the ARMSim simulator" />
	<title>QtARMSim: a graphical interface for the ARMSim
	simulator</title>
</head>

<body>
  <h1>QtARMSim User Manual</h1>

  <p><b>Table of contents</b></p>

  <p><a href="#Firmware">1. ARMSim firmware API</a><br/></p>
  <!--- &nbsp;&nbsp;&nbsp;&nbsp;<a href="#Archivo">1.1 Menu
  File</a><br/> -->


  <h2><a name="Firmware"></a>1. ARMSim firmware API</h2>

  <p>This section describes the Application Programming Interface
  (API) of the ARMSim firmware, which
  provides <a href="#Arithmetic">arithmetic</a>
  and <a href="#Display">display</a> functions.</p></p>

  <p>Please note that all the functions of the API follow the ARM
  convention for parameter passing and return. Thus, i) passed values
  use the registers from r0 to r3, then the stack if required; ii)
  values are returned using r0 and r1 if required; and iii) all the
  functions modify only registers r0 to r3, while all the other are
  preserved.</p>

  <h3><a name="Arithmetic"></a>1.1 Arithmetic functions</h3>

  <h4><tt>divide(unsigned int dividend, unsigned int divisor)</tt></h4>

  <p>Performs the 32 bits unsigned division dividend/divisor, where r0
  holds the dividend and r1 the divisor. The quotient is returned in
  r0 and the remainder in r1.</p>

  <p>If r1 is 0 both quotient and remainder will be 0xFFFFFFFF which
  is an impossible result for a correct 32 bit division.</p>

  <h4><tt>sdivide(int dividend, int divisor)</tt></h4>

  <p>Performs the 32 bits signed division dividend/divisor, where r0
  holds the dividend and r1 the divisor. The quotient is returned in
  r0 and the remainder in r1. The remainder always has the sign of the
  dividend ─unless the division is exact─.</p>

  <p>If r1 is 0 both quotient and remainder will be 0x7FFFFFFF which
  is an impossible result for a correct 32 bit division.</p>

  <p>If the dividend is 0x80000000 and the divisor is -1 the quotient
  returned is 0x80000000 as the positive range is exceeded. All the
  other combinations work as expected.</p>

  <h4><tt>sqrt(unsigned int val)</tt></h4>

  <p>Returns in r0 the positive, integer square root of the value
  passed in r0.</p>


  <h3><a name="Display"></a>1.2 Display functions</h3>

  <h4><tt>cls()</tt></h4>

  <p>Clears the display by filling it with the space character. Does
  not require nor return any value.</p>

  <h4><tt>fill(char c)</tt></h4>

  <p>Fills the display with the character passed in the LSB of
  r0. Does not return any value.</p>


  <h4><tt>printString(int column, int row, char *str)</tt></h4>

  <p>Shows the ASCIZ string whose address is passed in r2 starting at
  the display coordinates (column, row) where column is in r0 and row
  in r1.</p>

  <p>The number of characters printed, i.e., the length of the string,
  is returned in r0.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the string is printed in two rows
  or finishes out of the display area.</p>

  <h4><tt>printInt(int column, int row, int val)</tt></h4>

  <p>Shows the signed decimal value passed in r2 starting at the
  display coordinates (column, row) where column is in r0 and row in
  r1.</p>

  <p>Only significant characters, plus a - sign if required, are
  printed. The number of characters printed is returned in r0.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the number is printed in two rows
  or finishes out of the display area.</p>


  <h4><tt>printUInt(int column, int row, unsigned int val)</tt></h4>

  <p>Shows the unsigned decimal value passed in r2 starting at the
  display coordinates (column, row) where column is in r0 and row in
  r1.</p>

  <p>Only significance characters are printed. The number of
  characters printed is returned in r0.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the number is printed in two rows
  or finishes out of the display area.</p>

  <h4><tt>printWord(int column, int row, unsigned int val)</tt></h4>

  <p>Shows the hexadecimal value of the word passed in r2 starting at
  the display coordinates (column, row) where column is in r0 and row
  in r1.</p>

  <p>All 8 characters are printed, no value is returned.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the number is printed in two rows
  or finishes out of the display area.</p>

  <h4><tt>printHalf(int column, int row, unsigned int val)</tt></h4>

  <p>Shows the hexadecimal value of the half word passed in r2
  starting at the display coordinates (column, row) where column is in
  r0 and row in r1.</p>

  <p>All 4 characters are printed, no value is returned.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the number is printed in two rows
  or finishes out of the display area.</p>


  <h4><tt>printByte(int column, int row, unsigned int val)</tt></h4>

  <p>Shows the hexadecimal value of the byte passed in r2 starting at
  the display coordinates (column, row) where column is in r0 and row
  in r1.</p>

  <p>All 2 characters are printed, no value is returned.</p>

  <p>Does not verify if the coordinates are inside or outside the
  display; nor if the number is printed in two rows
  or finishes out of the display area.</p>

</body>
</html>
